<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Used-CSS Extractor</title>
  <style>
    body { font-family: sans-serif; padding: 1em; max-width: 800px; margin: auto }
    input, button, textarea { width: 100%; font-size: 1em; margin: 0.5em 0 }
    textarea { height: 300px; font-family: monospace; }
  </style>
</head>
<body>
  <h1>Extract Only the CSS You Use</h1>
  <p>Enter the full URL of the page you want to scan:</p>
  <input id="url" type="text" placeholder="https://…/carpenter_one.html" />
  <button id="go">Extract Used CSS</button>
  <h2>Output</h2>
  <textarea id="output" readonly placeholder="Your inlinable CSS will appear here…"></textarea>

  <script>
  async function extractUsedCSS(pageUrl) {
    // 1) Fetch page HTML
    let res = await fetch(pageUrl);
    if (!res.ok) throw new Error('Failed to fetch page: ' + res.status);
    let html = await res.text();
    let parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');

    // 2) Gather all CSS sources
    let cssSources = [];
    // 2a) Inline <style>
    doc.querySelectorAll('style').forEach(style => {
      cssSources.push({ href: null, text: style.textContent });
    });
    // 2b) External <link rel="stylesheet">
    let links = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'))
                     .map(l => new URL(l.href, pageUrl).href);
    for (let href of links) {
      let r2 = await fetch(href);
      if (r2.ok) {
        let txt = await r2.text();
        cssSources.push({ href, text: txt });
      } else {
        console.warn('Could not fetch CSS:', href, r2.status);
      }
    }

    // 3) For each CSS source, parse rules and test against the doc
    let used = '';
    for (let {href, text} of cssSources) {
      // create a temporary doc to parse CSSRules
      let tmpDoc = document.implementation.createHTMLDocument();
      let styleEl = tmpDoc.createElement('style');
      styleEl.textContent = text;
      tmpDoc.head.appendChild(styleEl);

      let rules;
      try { rules = styleEl.sheet.cssRules; }
      catch (e) { continue; /* parsing error or unsupported sheet */ }

      let sheetUsed = '';
      for (let rule of rules) {
        // style rules
        if (rule.type === CSSRule.STYLE_RULE) {
          let keep = false;
          try { keep = !!doc.querySelector(rule.selectorText); }
          catch(_) { keep = true; } // pseudo-classes, dynamic selectors
          if (keep) sheetUsed += rule.cssText + "\n";
        }
        // media rules
        else if (rule.type === CSSRule.MEDIA_RULE) {
          let block = '';
          for (let mr of rule.cssRules) {
            let ok = false;
            try { ok = !!doc.querySelector(mr.selectorText); }
            catch(_) { ok = true; }
            if (ok) block += "  " + mr.cssText + "\n";
          }
          if (block) sheetUsed += `@media ${rule.conditionText} {\n${block}}\n`;
        }
      }
      if (sheetUsed) {
        used += `/* from ${href||'inline <style>'} */\n` + sheetUsed + "\n";
      }
    }

    return used;
  }

  document.getElementById('go').addEventListener('click', async () => {
    let url = document.getElementById('url').value.trim();
    if (!url) return alert('Enter a URL first');
    document.getElementById('output').value = '⏳ extracting…';
    try {
      let css = await extractUsedCSS(url);
      document.getElementById('output').value = css || '⚠️ No used CSS found.';
    } catch (err) {
      document.getElementById('output').value = 'Error: ' + err;
    }
  });
  </script>
</body>
</html>
